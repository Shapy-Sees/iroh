// src/config/dahdi.ts
//
// DAHDI configuration management class that handles:
// - Reading and writing DAHDI system configuration
// - Parsing and validating DAHDI settings
// - Managing spans and channels
// - Hardware detection and verification
// - Configuration persistence
// - Error handling and logging

import { promises as fs } from 'fs';
import { exec } from 'child_process';
import { promisify } from 'util';
import { logger } from '../utils/logger';
import {
    DAHDISystemConfig,
    DAHDISpanConfig,
    DAHDIChannelConfig,
    DAHDISignalingType,
    DAHDIHardwareInfo,
    DAHDIErrorCode
} from '../types/dahdi';

const execAsync = promisify(exec);

export class DAHDIConfig {
    private readonly configPath: string = '/etc/dahdi/system.conf';
    private readonly modulesPath: string = '/etc/dahdi/modules';
    private config: DAHDISystemConfig;
    private hardwareInfo: DAHDIHardwareInfo | null = null;

    constructor() {
        // Initialize with default configuration
        this.config = {
            echocancel: {
                enabled: true,
                taps: 128
            },
            loadzone: ['us'],
            defaultzone: 'us',
            spans: []
        };
    }

    /**
     * Load DAHDI configuration from system files
     */
    public async load(): Promise<void> {
        try {
            logger.info('Loading DAHDI configuration');
            
            // Check if config file exists
            try {
                await fs.access(this.configPath);
            } catch {
                logger.warn('DAHDI config file not found, creating default');
                await this.createDefaultConfig();
            }
            
            // Read the main configuration file
            const configContent = await fs.readFile(this.configPath, 'utf-8');
            
            // Parse the configuration
            this.config = this.parseConfig(configContent);
            
            // Load hardware information
            await this.loadHardwareInfo();
            
            logger.info('DAHDI configuration loaded successfully', {
                spans: this.config.spans.length,
                loadzone: this.config.loadzone,
                defaultzone: this.config.defaultzone
            });
        } catch (error) {
            logger.error('Failed to load DAHDI configuration:', error);
            throw error;
        }
    }

    /**
     * Save current configuration to file
     */
    private async save(): Promise<void> {
        try {
            // Generate configuration content
            const content = this.generateConfigContent();
            
            // Create backup of existing config
            const backupPath = `${this.configPath}.bak`;
            try {
                await fs.copyFile(this.configPath, backupPath);
                logger.debug('Created config backup', { path: backupPath });
            } catch (error) {
                logger.warn('Failed to create config backup:', error);
            }
            
            // Write new configuration
            await fs.writeFile(this.configPath, content, 'utf-8');
            logger.info('DAHDI configuration saved successfully');
            
        } catch (error) {
            logger.error('Failed to save DAHDI configuration:', error);
            throw error;
        }
    }

    /**
     * Generate DAHDI configuration file content
     */
    private generateConfigContent(): string {
        const lines: string[] = [
            '# DAHDI Configuration',
            '# Generated by Iroh',
            '',
            `# Echo Cancellation Configuration`,
            `echocanceller=mg2,${this.config.echocancel.taps}`,
            '',
            '# Zone Configuration',
            `loadzone=${this.config.loadzone.join(',')}`,
            `defaultzone=${this.config.defaultzone}`,
            ''
        ];

        // Add span configurations
        this.config.spans.forEach(span => {
            lines.push(`# Span ${span.span}`);
            lines.push(`span=${span.span},1,0,${span.coding || 'ami'},${span.framing || 'esf'}`);
            
            // Add channel configurations
            span.channels.forEach(channel => {
                lines.push(this.generateChannelConfig(channel));
            });
            lines.push('');
        });

        return lines.join('\n');
    }

    /**
     * Generate configuration line for a channel
     */
    private generateChannelConfig(channel: DAHDIChannelConfig): string {
        const parts = [
            channel.signaling,
            channel.channel,
            channel.echocancel?.enabled ? 'echocanceller=mg2' : '',
            channel.callerid?.enabled ? `callerid=${channel.callerid.format}` : '',
            channel.impedance ? `impedance=${channel.impedance}` : ''
        ].filter(Boolean);

        return parts.join(',');
    }

    /**
     * Create default DAHDI configuration
     */
    private async createDefaultConfig(): Promise<void> {
        const defaultConfig = `# Default DAHDI Configuration
echocanceller=mg2,128
loadzone=us
defaultzone=us

# Default span configuration for OpenVox A400P
span=1,1,0,esf,b8zs
fxs0=1
`;

        await fs.writeFile(this.configPath, defaultConfig, 'utf-8');
        logger.info('Created default DAHDI configuration');
    }

    /**
     * Load hardware information using dahdi_hardware command
     */
    private async loadHardwareInfo(): Promise<void> {
        try {
            const { stdout } = await execAsync('dahdi_hardware -v');
            this.hardwareInfo = this.parseHardwareOutput(stdout);
            logger.debug('DAHDI hardware info loaded', this.hardwareInfo);
        } catch (error) {
            logger.error('Failed to load hardware info:', error);
            throw error;
        }
    }

    /**
     * Parse hardware detection output
     */
    private parseHardwareOutput(output: string): DAHDIHardwareInfo {
        const info: DAHDIHardwareInfo = {
            name: 'Unknown',
            location: '',
            spans: 0,
            channelsPerSpan: 0,
            manufacturer: '',
            capabilities: 0
        };

        const lines = output.split('\n');
        
        for (const line of lines) {
            if (line.includes('OpenVox A400P')) {
                const matches = line.match(/pci\s+(\S+)/i);
                info.name = 'OpenVox A400P';
                info.location = matches ? matches[1] : '';
                info.spans = 1;
                info.channelsPerSpan = 4;
                info.manufacturer = 'OpenVox';
                // Basic FXS capabilities
                info.capabilities = 0x01;
                break;
            }
        }

        return info;
    }

    /**
     * Parse DAHDI configuration content
     */
    private parseConfig(content: string): DAHDISystemConfig {
        const config: DAHDISystemConfig = {
            echocancel: { enabled: false },
            loadzone: [],
            defaultzone: 'us',
            spans: []
        };

        let currentSpan: DAHDISpanConfig | null = null;

        for (const line of content.split('\n')) {
            const trimmed = line.trim();
            
            // Skip comments and empty lines
            if (trimmed.startsWith('#') || !trimmed) continue;

            if (trimmed.startsWith('span=')) {
                currentSpan = this.parseSpanConfig(trimmed);
                config.spans.push(currentSpan);
            } else if (trimmed.startsWith('loadzone')) {
                config.loadzone = trimmed.split('=')[1].split(',');
            } else if (trimmed.startsWith('defaultzone')) {
                config.defaultzone = trimmed.split('=')[1];
            } else if (trimmed.startsWith('echocanceller')) {
                const parts = trimmed.split('=')[1].split(',');
                config.echocancel = {
                    enabled: true,
                    taps: parseInt(parts[1]) || 128
                };
            } else if (currentSpan && this.isChannelConfig(trimmed)) {
                currentSpan.channels.push(this.parseChannelConfig(trimmed));
            }
        }

        return config;
    }

    /**
     * Parse span configuration line
     */
    private parseSpanConfig(line: string): DAHDISpanConfig {
        const parts = line.split('=')[1].split(',');
        return {
            span: parseInt(parts[0]),
            timing: parseInt(parts[1]) || 0,
            lbo: parseInt(parts[2]) || 0,
            framing: parts[3],
            coding: parts[4],
            channels: []
        };
    }

    /**
     * Check if a line contains channel configuration
     */
    private isChannelConfig(line: string): boolean {
        return /^(fxs|fxo|bchan|dchan)/.test(line);
    }

    /**
     * Parse channel configuration line
     */
    private parseChannelConfig(line: string): DAHDIChannelConfig {
        const parts = line.split(',');
        
        return {
            channel: parseInt(parts[1]) || 1,
            signaling: parts[0] as DAHDISignalingType,
            echocancel: {
                enabled: parts.includes('echocanceller=mg2')
            },
            callerid: {
                enabled: parts.some(p => p.startsWith('callerid')),
                format: 'bell'
            }
        };
    }

    /**
     * Add a new span to the configuration
     */
    public async addSpan(span: DAHDISpanConfig): Promise<void> {
        // Validate span number doesn't already exist
        if (this.config.spans.some(s => s.span === span.span)) {
            throw new Error(`Span ${span.span} already exists`);
        }

        this.config.spans.push(span);
        await this.save();
        await this.reload();
    }

    /**
     * Update an existing span configuration
     */
    public async updateSpan(spanNumber: number, updates: Partial<DAHDISpanConfig>): Promise<void> {
        const span = this.config.spans.find(s => s.span === spanNumber);
        if (!span) {
            throw new Error(`Span ${spanNumber} not found`);
        }

        Object.assign(span, updates);
        await this.save();
        await this.reload();
    }

    /**
     * Remove a span from configuration
     */
    public async removeSpan(spanNumber: number): Promise<void> {
        const index = this.config.spans.findIndex(s => s.span === spanNumber);
        if (index === -1) {
            throw new Error(`Span ${spanNumber} not found`);
        }

        this.config.spans.splice(index, 1);
        await this.save();
        await this.reload();
    }

    /**
     * Reload DAHDI system with new configuration
     */
    private async reload(): Promise<void> {
        try {
            logger.info('Reloading DAHDI configuration');
            await execAsync('dahdi_cfg -vv');
            logger.info('DAHDI configuration reloaded successfully');
        } catch (error) {
            logger.error('Failed to reload DAHDI configuration:', error);
            throw error;
        }
    }

    /**
     * Get the current configuration
     */
    public getConfig(): DAHDISystemConfig {
        return { ...this.config };
    }

    /**
     * Get hardware information
     */
    public getHardwareInfo(): DAHDIHardwareInfo | null {
        return this.hardwareInfo;
    }

    /**
     * Validate configuration against hardware capabilities
     */
    public async validateConfig(): Promise<boolean> {
        if (!this.hardwareInfo) {
            throw new Error('Hardware information not available');
        }

        // Check basic configuration
        if (!this.config.loadzone || this.config.loadzone.length === 0) {
            logger.error('No load zones configured');
            return false;
        }

        // Validate spans against hardware
        for (const span of this.config.spans) {
            // Check span number
            if (span.span > this.hardwareInfo.spans) {
                logger.error('Invalid span number', { span: span.span });
                return false;
            }

            // Check channel count
            if (span.channels.length > this.hardwareInfo.channelsPerSpan) {
                logger.error('Too many channels configured for span', {
                    span: span.span,
                    channels: span.channels.length,
                    max: this.hardwareInfo.channelsPerSpan
                });
                return false;
            }

            // Validate channel configuration
            for (const channel of span.channels) {
                if (!this.validateChannelConfig(channel)) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Validate individual channel configuration
     */
    private validateChannelConfig(channel: DAHDIChannelConfig): boolean {
        // Validate signaling type
        if (!['fxs_ls', 'fxs_gs', 'fxs_ks', 'unused'].includes(channel.signaling)) {
            logger.error('Invalid signaling type', {
                channel: channel.channel,
                signaling: channel.signaling
            });
            return false;
        }

        // Validate impedance if set
        if (channel.impedance && ![600, 900].includes(channel.impedance)) {
            logger.error('Invalid impedance value', {
                channel: channel.channel,
                impedance: channel.impedance
            });
            return false;
        }

        return true;
    }
}